# Second

> 即使你只是使用標準庫中的排序函數，學習排序算法仍然有三大實際意義：
>
> - 對排序算法的分析將有助於你全面理解本書中比較算法性能的方法；
> - 類似的技術也能有效解決其他類型的問題；
> - 排序算法常常是我們解決其他問題的第一步。
>
> 更重要的是這些算法都很經典、優雅和高效。
>
> p.152

排序算法常常是我們解決其他問題的第一步

> 無論數組的初始狀態是什麼，排序算法都能成功嗎？
> 謹慎起見，我們會在測試代碼中添加一條 語句 assert isSorted(a); 來確認排序後數組元素都是有序的。
> 儘管一般都會測試代碼並從數學 上證明算法的正確性，但在實現每個排序算法時加上這條語句仍然是必要的。
>
> p.154

類似土木的設計與檢核的差異。

> 插入排序不會訪問索引右側的元素，而選擇排序不會訪問索引左側的元素。
>
> p.159

選擇排序 (Selection)

- 從未排序之中選擇最小的，放到已排序的數組之後。
- 比較: n^2/2
- 交換: n

插入排序

- 將訪問到的元素，插入已排序的數組之中。
- 比較:

> 因此，不止是排序，對於本書中的每個問題我們都會沿用這種方式，首先學習的就是最初級的相關算法。
> SortCompare 這樣的程序對於這種漸進式的算法研究十分重要。
> 每一步，我們都能用這 類程序來了解新的或是改進後的算法的性能是否產生了預期的進步。
>
> p.162

建立可量測的標準，這樣才知道改變有沒有進步。

> 通過提升速度來解決其他方式無法解決的問題是研究算法的設計和性能的主要原因之一
>
> p.164
